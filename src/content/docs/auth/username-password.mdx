---
title: Username & Password
---

:::caution
A password based authentication requires a database (to store the passwords). If you want to only use cookies for auth, then a different approach is required.
:::

:::danger
Username authentication has no implicit way to send a forgotten password. **If a user forgets their username or password, their account may be unrecoverable.**

Consider requiring an email or using an email-based approach instead.
:::

## Schema

```ts title="@/db/schema.ts" {3} ins={13-14}
import "server-only"; // <- if you are using react server components

import { pgTable, timestamp, uuid, varchar } from "drizzle-orm/pg-core";

export const users = pgTable("users", {
  id: uuid("id").primaryKey().defaultRandom(),
  createdAt: timestamp("created_at", { precision: 3, withTimezone: true })
    .notNull()
    .defaultNow(),
  updatedAt: timestamp("updated_at", { precision: 3, withTimezone: true })
    .notNull()
    .defaultNow(),
  username: varchar("username", { length: 15 }).notNull().unique(),
  passwordHash: varchar("password_hash", { length: 97 }).notNull(),
});
```

<details>
  <summary>Why use a `varchar(n)` instead of `text`?</summary>

    In PostgreSQL, `varchar` allows you to specify a [maximum length for the column without using blank character padding](https://www.postgresql.org/docs/current/datatype-character.html#DATATYPE-CHARACTER).

    Without setting a limit, the size of the input could be as large as the column allows. The maximum size for a single field in PostgreSQL is [1 GB](https://www.postgresql.org/docs/current/limits.html#LIMITS-TABLE). That could be exploited by a bad actor to use extra space and processing in your database.

    :::caution
    Restricting the length is only a partial solution to sanitizing user input. Doing so on the database columns is a last line of defense.

    Input sanitization and validation should be done on the server before ever reaching the database.
    :::

    :::note
    `text` columns are more performant than `varchar(n)` columns because they don't include the length check

    In a future version of wunshot, `text` with a `CHECK` constraint may be the recommended approach. That would enable a more comprehensive check for accepted characters and length without the overhead of the `varchar(n)` check.

    At time of writing, [Drizzle ORM does not support `CHECK` constraints](https://orm.drizzle.team/docs/indexes-constraints#check).
    :::

</details>

<details>
  <summary>Why use `{ length: 15 }` for `username`?</summary>

    Specifying the actual number to use for the limit comes down to personal preference and UI constraints. I chose 15 semi-arbitrarily because [that's what Twitter/X uses](https://help.x.com/en/managing-your-account/x-username-rules).

</details>

<details>
  <summary>Why use `{ length: 97 }` for `password_hash`?</summary>
    For this recommendation, I assume that passwords will be run through [argon2id with recommended settings](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html#argon2id) before being sent to the database. The total output should be 97 characters long if the hash length is set to 32 bytes (the digest will be 43 characters).

    **Ideally, you should use the exact length of the output of whatever hashing algorithm you are using.** But if you aren't sure, `text` is an adequate choice.

    <details>
      <summary>Why not use `pgcrypto crypt()`?</summary>
        `pgcrypto` provides a built-in [`crypt()` function that hashes passwords](https://www.postgresql.org/docs/current/pgcrypto.html#PGCRYPTO-PASSWORD-HASHING-FUNCS).
        There are four main reasons wunshot opts not to use it:
        1. Relying on a database function for hashing means that the password would need to remain in plaintext while in transit. (All transit between your app and the database should be encrypted, but that's a different topic.)
        2. The recommended `argon2` algorithm is not available in `pgcrypto`.
        3. `pgcrypto` integration with Drizzle ORM is not straight-forward. It would involve a lot of magic `sql`
        4. Hashing in the server/application layer continues to _just work_ if a different RDBMS is used.
    </details>

</details>

## Functions

### Create user

### Sign in

### Sign out

### Update password

### Update username
